=proto
int duk_pcall(duk_context *ctx, int nargs, int errhandler_index);

=stack
[ ... func! arg1! ...! argN! ] -> [ ... retval! ]  (if success, return value == 0)
[ ... func! arg1! ...! argN! ] -> [ ... err! ]  (if failure, return value != 0)

=summary
<p>Call target function <tt>func</tt> with <tt>nargs</tt> arguments
(not counting the function itself).  The function and its arguments
are replaced by a single return value or a single error value.
An error thrown during the function call is caught.  <tt>errhandler_index</tt> points
to an error handler function in the current stack frame (below call arguments) which
can modify an error value before it is thrown; to use the default error handler,
set <tt>errhandler_index</tt> to <tt>DUK_INVALID_INDEX</tt>.</p>
</p>

<p>The return value is one of:</p>
<ul>
<li><tt>DUK_EXEC_SUCCESS</tt> (0): call succeeded, <tt>nargs</tt> arguments are replaced
    with a single return value.  (This return code constant is guaranteed to be zero, so
    that one can check for success with a "zero or non-zero" check.)</li>
<li><tt>DUK_EXEC_ERROR</tt>: call failed, <tt>nargs</tt> arguments are replaced with a
    single error value.  (In exceptional cases, e.g. when there are too few
    arguments on the value stack, the call returns non-zero but may leave the stack
    in an inconsistent state.)</li>
</ul>

<div class="note">
Unlike most Duktape API calls, this call returns zero on success.  This allows
multiple error codes to be defined later.
</div>

<p>The target function <tt>this</tt> binding is initially set to
<tt>undefined</tt>.  If the target function is not strict, the binding
is replaced by the global object before the function is invoked; see
<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-10.4.3">Entering Function Code</a>.
If you want to control the <tt>this</tt> binding, you can use
<tt><a href="#duk_pcall_method">duk_pcall_method()</a></tt> or
<tt><a href="#duk_pcall_prop">duk_pcall_prop()</a></tt> instead.</p>

=example
/* Assume target function is already on stack at func_idx; the target
 * function adds arguments and returns the result.
 */

int func_idx;
int rc;

duk_dup(ctx, func_idx);
duk_push_int(ctx, 2);
duk_push_int(ctx, 3);
rc = duk_pcall(ctx, 2, DUK_INVALID_INDEX);  /* [ ... func 2 3 ] -> [ 5 ] */
if (rc == DUK_EXEC_SUCCESS) {
  printf("2+3=%d\n", duk_get_int(ctx, -1));
} else {
  printf("error: %s\n", duk_to_string(ctx, -1));
}
duk_pop(ctx);

=tags
call

=fixme
Refine return codes.
Error handler model to be cleaned up.
