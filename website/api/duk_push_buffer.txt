=proto
void *duk_push_buffer(duk_context *ctx, size_t size, int dynamic);

=stack
[ ... ] -> [ ... buf! ]

=summary
<p>Allocate a new buffer of <tt>size</tt> bytes and push it to the value stack.
Returns a non-<tt>NULL</tt> pointer to the buffer data area; for a zero-size buffer,
may return either <tt>NULL</tt> or <tt>non-NULL</tt>.  The buffer data area is
automatically zeroed.  If <tt>dynamic</tt> is non-zero, the buffer will be resizable,
otherwise the buffer will have a fixed size.  Throws an error if allocation fails.</p>

<p>There are also shortcut variants
<tt><a href="#duk_push_fixed_buffer">duk_push_fixed_buffer()</a></tt> and
<tt><a href="#duk_push_dynamic_buffer">duk_push_dynamic_buffer()</a></tt>.</p>

<div class="note">
A dynamic buffer requires two memory allocations internally: one for the buffer
header and another for the currently allocated data area.  A fixed buffer only
requires a single allocation: the data area follows the buffer header.
</div>

=example
/* Allocate a fixed buffer of 1024 bytes.  There is no need to check for
 * the return value: an error is thrown if allocation fails.
 */

void *p;

p = duk_push_buffer(ctx, 1024, 0);
printf("allocated buffer, data area: %p\n", p);

=tags
stack
buffer
